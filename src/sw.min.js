(() => {
  "use strict";

  let cancelled = false;

  // Handle messages from clients
  self.addEventListener("message", (event) => {
    if (event.data && event.data.type === "SKIP_WAITING") {
      self.skipWaiting();
    }
    if (event.data && event.data.type === "CLEAR_CACHES") {
      caches
        .keys()
        .then((cacheNames) =>
          Promise.all(cacheNames.map((cacheName) => caches.delete(cacheName)))
        );
    }
  });

  // Immediately install and skip waiting
  self.addEventListener("install", (event) => {
    self.skipWaiting();
  });

  // Claim clients on activation and clear caches
  self.addEventListener("activate", (event) => {
    event.waitUntil(
      Promise.all([
        clients.claim(),
        self.skipWaiting(),
        caches
          .keys()
          .then((cacheNames) =>
            Promise.all(cacheNames.map((cacheName) => caches.delete(cacheName)))
          ),
      ])
    );
  });

  // Handle fetch events
  self.addEventListener("fetch", (event) => {
    const requestURL = event.request.url;
    // Only handle WebTorrent streaming requests; let other requests proceed normally.
    if (!requestURL.includes("/webtorrent/")) {
      return;
    }

    const responsePromise = (async () => {
      // Handle keepalive requests
      if (requestURL.includes("/webtorrent/keepalive/")) {
        return new Response();
      }

      // Handle cancel requests
      if (requestURL.includes("/webtorrent/cancel/")) {
        return new Response(
          new ReadableStream({
            cancel() {
              cancelled = true;
            },
          })
        );
      }

      // Handle streaming requests
      return (async function ({ request }) {
        const { url, method, headers, destination } = request;
        const windowClients = await clients.matchAll({
          type: "window",
          includeUncontrolled: true,
        });
        const [clientResponse, port] = await new Promise((resolve) => {
          for (const client of windowClients) {
            const channel = new MessageChannel();
            channel.port1.onmessage = ({ data }) => {
              resolve([data, channel.port1]);
            };
            client.postMessage(
              {
                url,
                method,
                headers: Object.fromEntries(headers.entries()),
                scope: self.registration.scope,
                destination,
                type: "webtorrent",
              },
              [channel.port2]
            );
          }
        });

        let timeoutId = null;
        const closeChannel = () => {
          port.postMessage(false);
          clearTimeout(timeoutId);
          port.onmessage = null;
        };

        // Clone and update headers to prevent caching.
        const responseHeaders = new Headers(clientResponse.headers);
        responseHeaders.set(
          "Cache-Control",
          "no-cache, no-store, must-revalidate, max-age=0"
        );
        responseHeaders.set("Pragma", "no-cache");
        responseHeaders.set("Expires", "0");

        // If the response is not a streaming request, return it directly.
        if (clientResponse.body !== "STREAM") {
          closeChannel();
          return new Response(clientResponse.body, {
            status: clientResponse.status,
            statusText: clientResponse.statusText,
            headers: responseHeaders,
          });
        }

        // Otherwise, stream the response via a ReadableStream.
        return new Response(
          new ReadableStream({
            pull(controller) {
              return new Promise((resolvePull) => {
                port.onmessage = ({ data }) => {
                  if (data) {
                    controller.enqueue(data);
                  } else {
                    closeChannel();
                    controller.close();
                  }
                  resolvePull();
                };

                if (!cancelled && destination !== "document") {
                  clearTimeout(timeoutId);
                  timeoutId = setTimeout(() => {
                    closeChannel();
                    resolvePull();
                  }, 5000);
                }

                port.postMessage(true);
              });
            },
            cancel() {
              closeChannel();
            },
          }),
          {
            status: clientResponse.status,
            statusText: clientResponse.statusText,
            headers: responseHeaders,
          }
        );
      })(event);
    })();

    if (responsePromise) {
      event.respondWith(responsePromise);
    }
  });
})();
