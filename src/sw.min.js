(() => {
  "use strict";

  let cancelled = false;

  // Handle skip waiting message
  self.addEventListener("message", (event) => {
    if (event.data && event.data.type === "SKIP_WAITING") {
      self.skipWaiting();
    }
  });

  // Immediately install and activate
  self.addEventListener("install", () => {
    self.skipWaiting();
  });

  // Claim clients on activation and clear caches
  self.addEventListener("activate", (event) => {
    event.waitUntil(
      Promise.all([
        clients.claim(),
        self.skipWaiting(),
        caches.keys().then((cacheNames) =>
          Promise.all(cacheNames.map((cacheName) => caches.delete(cacheName)))
        ),
      ])
    );
  });

  // Handle fetch events
  self.addEventListener("fetch", (event) => {
    const responsePromise = (() => {
      const requestURL = event.request.url;
      // Only handle WebTorrent streaming requests
      // Since our SW is registered with scope "/" the expected URL prefix is "/webtorrent/"
      if (!requestURL.includes("/webtorrent/")) {
        return null;
      }

      // Handle keepalive requests
      if (requestURL.includes("/webtorrent/keepalive/")) {
        return new Response();
      }

      // Handle cancel requests
      if (requestURL.includes("/webtorrent/cancel/")) {
        return new Response(
          new ReadableStream({
            cancel() {
              cancelled = true;
            },
          })
        );
      }

      // Handle streaming requests
      return (async function ({ request }) {
        const { url, method, headers, destination } = request;

        // Get all window clients
        const windowClients = await clients.matchAll({
          type: "window",
          includeUncontrolled: true,
        });

        // Create a message channel and wait for a response from a client
        const [clientResponse, port] = await new Promise((resolve) => {
          for (const client of windowClients) {
            const channel = new MessageChannel();
            channel.port1.onmessage = ({ data }) => {
              resolve([data, channel.port1]);
            };
            client.postMessage(
              {
                url,
                method,
                headers: Object.fromEntries(headers.entries()),
                scope: self.registration.scope,
                destination,
                type: "webtorrent",
              },
              [channel.port2]
            );
          }
        });

        let timeoutId = null;
        const closeChannel = () => {
          port.postMessage(false);
          clearTimeout(timeoutId);
          port.onmessage = null;
        };

        // If the response is not a streaming request, return a normal response
        if (clientResponse.body !== "STREAM") {
          closeChannel();
          return new Response(clientResponse.body, clientResponse);
        }

        // Otherwise, handle streaming response using a ReadableStream
        return new Response(
          new ReadableStream({
            pull(controller) {
              return new Promise((resolvePull) => {
                port.onmessage = ({ data }) => {
                  if (data) {
                    controller.enqueue(data);
                  } else {
                    closeChannel();
                    controller.close();
                  }
                  resolvePull();
                };

                if (!cancelled && destination !== "document") {
                  clearTimeout(timeoutId);
                  timeoutId = setTimeout(() => {
                    closeChannel();
                    resolvePull();
                  }, 5000);
                }

                port.postMessage(true);
              });
            },
            cancel() {
              closeChannel();
            },
          }),
          clientResponse
        );
      })(event);
    })();

    if (responsePromise) {
      event.respondWith(responsePromise);
    }
  });
})();
