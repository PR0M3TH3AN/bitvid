<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Bitvid Content Appeals Form</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        max-width: 600px;
        color: #fff;
        background: transparent; /* transparent background */
      }
      label {
        display: inline-block;
        margin: 8px 0 4px 0;
        font-weight: bold;
        color: #fff;
      }
      input,
      textarea,
      select {
        width: 100%;
        padding: 6px;
        margin-bottom: 16px;
        box-sizing: border-box;
        background-color: #234566; /* dark blue */
        color: #fff; /* white text */
        border: 1px solid #888;
      }
      button {
        padding: 10px 16px;
        cursor: pointer;
      }
      h1,
      h2,
      h3 {
        margin-top: 24px;
        color: #fff;
      }
      p {
        color: #fff;
      }
      #status-message {
        white-space: pre;
        margin-top: 1em;
        font-size: 0.9em;
      }
    </style>
  </head>
  <body>
    <h1>Bitvid Content Appeals Form</h1>
    <form id="appeal-form">
      <h3>1. User Information</h3>
      <label for="npub">Nostr Public Key (npub)</label>
      <input
        type="text"
        id="npub"
        name="npub"
        placeholder="Your npub"
        required
      />

      <label for="contactMethod">Contact Method (if applicable)</label>
      <input
        type="text"
        id="contactMethod"
        name="contactMethod"
        placeholder="Nostr DM, email, etc."
      />

      <h3>2. Content Details</h3>
      <label for="videoTitle">Title of the Video</label>
      <input
        type="text"
        id="videoTitle"
        name="videoTitle"
        placeholder="Exact video title"
        required
      />

      <label for="magnetLink">Magnet Link</label>
      <input
        type="text"
        id="magnetLink"
        name="magnetLink"
        placeholder="Magnet link for the video"
        required
      />

      <label for="submissionDate"
        >Date of Content Submission (MM/DD/YYYY)</label
      >
      <input
        type="text"
        id="submissionDate"
        name="submissionDate"
        placeholder="MM/DD/YYYY"
        required
      />

      <h3>3. Reason for Appeal</h3>
      <label for="whyUnfair"
        >Why do you believe your content was unfairly blocked?</label
      >
      <textarea id="whyUnfair" name="whyUnfair" rows="4" required></textarea>

      <label for="guidelinesFit"
        >Does your content fit within bitvid's Community Guidelines?
        (Yes/No)</label
      >
      <input
        type="text"
        id="guidelinesFit"
        name="guidelinesFit"
        placeholder="Yes or No"
        required
      />

      <label for="whichGuidelines"
        >If yes, which guideline(s) support your appeal?</label
      >
      <textarea id="whichGuidelines" name="whichGuidelines" rows="3"></textarea>

      <label for="contentEdited"
        >Was this content edited after being blocked? (Yes/No)</label
      >
      <input
        type="text"
        id="contentEdited"
        name="contentEdited"
        placeholder="Yes or No"
        required
      />

      <label for="changesMade">If yes, what changes were made?</label>
      <textarea id="changesMade" name="changesMade" rows="3"></textarea>

      <h3>4. Additional Context</h3>
      <label for="misunderstanding"
        >Was there any misunderstanding or misclassification?</label
      >
      <textarea
        id="misunderstanding"
        name="misunderstanding"
        rows="3"
      ></textarea>

      <label for="externalRefs"
        >Are there external references that validate your appeal?</label
      >
      <textarea id="externalRefs" name="externalRefs" rows="3"></textarea>

      <h3>5. Declaration</h3>
      <p>
        By submitting this appeal, you confirm that:<br />
        - You are the original creator or authorized representative of the
        content in question.<br />
        - Your appeal is submitted in good faith and aligns with bitvid’s
        policies.<br />
        - You understand that final decisions are at the discretion of bitvid’s
        moderation process.
      </p>
      <label for="signature">Signature (Digital or Written)</label>
      <input type="text" id="signature" name="signature" required />

      <label for="dateSigned">Date (MM/DD/YYYY)</label>
      <input
        type="text"
        id="dateSigned"
        name="dateSigned"
        placeholder="MM/DD/YYYY"
        required
      />

      <button type="submit">Submit Appeal</button>
    </form>
    <p>
      <strong>Processing Time:</strong> Appeals will be reviewed within 7-14
      days.
    </p>
    <hr />
    <div id="status-message"></div>

    <script>
      /***********************************
       * Minimal "nostr-tools" subset
       ***********************************/

      // Simple bech32 decoding for npub => hex
      const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
      function polymod(values) {
        let chk = 1;
        for (let p = 0; p < values.length; p++) {
          const top = chk >> 25;
          chk = ((chk & 0x1ffffff) << 5) ^ values[p];
          for (let i = 0; i < 5; i++) {
            if (((top >> i) & 1) === 1) {
              chk ^= (0x3b6a57b2 >>> (5 * (4 - i))) & 0x1f;
            }
          }
        }
        return chk;
      }
      function hrpExpand(hrp) {
        const ret = [];
        for (let p = 0; p < hrp.length; p++) {
          ret.push(hrp.charCodeAt(p) >> 5);
        }
        ret.push(0);
        for (let p = 0; p < hrp.length; p++) {
          ret.push(hrp.charCodeAt(p) & 31);
        }
        return ret;
      }
      function bech32Decode(str) {
        let lower = false;
        let upper = false;
        for (let i = 0; i < str.length; i++) {
          const c = str.charCodeAt(i);
          if (c >= 0x30 && c <= 0x39) continue;
          if (c >= 0x41 && c <= 0x5a) {
            if (lower) throw new Error("Mixed-case string");
            upper = true;
          }
          if (c >= 0x61 && c <= 0x7a) {
            if (upper) throw new Error("Mixed-case string");
            lower = true;
          }
        }
        str = str.toLowerCase();
        const sepPos = str.lastIndexOf("1");
        if (sepPos === -1) throw new Error("No separator character for bech32");
        if (sepPos === 0) throw new Error("Empty HRP");
        const hrp = str.slice(0, sepPos);
        const data = [];
        for (let i = sepPos + 1; i < str.length; i++) {
          const d = ALPHABET.indexOf(str[i]);
          if (d === -1) throw new Error("Unknown character in bech32");
          data.push(d);
        }
        if (data.length < 6) throw new Error("Data too short");
        const chk = polymod(hrpExpand(hrp).concat(data));
        if (chk !== 1) throw new Error("Invalid checksum");
        return { hrp, data: data.slice(0, data.length - 6) };
      }
      function convertBits(data, inBits, outBits, pad = true) {
        let value = 0;
        let bits = 0;
        const result = [];
        const maxV = (1 << outBits) - 1;
        for (let i = 0; i < data.length; i++) {
          value = (value << inBits) | data[i];
          bits += inBits;
          while (bits >= outBits) {
            bits -= outBits;
            result.push((value >> bits) & maxV);
          }
        }
        if (pad) {
          if (bits > 0) {
            result.push((value << (outBits - bits)) & maxV);
          }
        } else {
          if (bits >= inBits) throw new Error("Excess padding");
          if (((value << (outBits - bits)) & maxV) !== 0)
            throw new Error("Non-zero padding");
        }
        return result;
      }
      function decodeNpubToHex(npub) {
        const { hrp, data } = bech32Decode(npub);
        if (hrp !== "npub") {
          throw new Error("Not an npub");
        }
        const converted = convertBits(data, 5, 8, false);
        return bytesToHex(new Uint8Array(converted));
      }
      function bytesToHex(uint8a) {
        let hex = "";
        for (let i = 0; i < uint8a.length; i++) {
          const b = uint8a[i];
          hex += b.toString(16).padStart(2, "0");
        }
        return hex;
      }

      // Simple SHA-256 for event hashing
      // Here we'll rely on browser's crypto.subtle
      async function sha256Hex(msgUint8) {
        const hashBuffer = await crypto.subtle.digest("SHA-256", msgUint8);
        const hashArray = new Uint8Array(hashBuffer);
        let hex = "";
        for (let i = 0; i < hashArray.length; i++) {
          hex += hashArray[i].toString(16).padStart(2, "0");
        }
        return hex;
      }

      // Helper to build event.id
      // This is the "serialize" approach in NIP-01
      async function getEventHash(evt) {
        const { kind, pubkey, created_at, tags, content } = evt;
        const payload = JSON.stringify([
          0,
          pubkey,
          created_at,
          kind,
          tags,
          content,
        ]);
        const enc = new TextEncoder();
        const encodedPayload = enc.encode(payload);
        return await sha256Hex(encodedPayload);
      }

      // Minimal "SimplePool" that can publish events
      class SimplePool {
        constructor() {
          this.conns = {};
        }
        async connectRelay(url) {
          return new Promise((resolve, reject) => {
            if (
              this.conns[url] &&
              this.conns[url].readyState === WebSocket.OPEN
            ) {
              resolve(this.conns[url]);
              return;
            }
            const ws = new WebSocket(url);
            ws.onopen = () => {
              this.conns[url] = ws;
              resolve(ws);
            };
            ws.onerror = (err) => {
              reject(err);
            };
          });
        }
        async publish(urls, event) {
          // For each URL, ensure a WS connection, then send
          return Promise.all(
            urls.map(async (url) => {
              try {
                const ws = await this.connectRelay(url);
                const msg = ["EVENT", event];
                ws.send(JSON.stringify(msg));
              } catch (err) {
                throw new Error(`Failed to publish to ${url}: ${err.message}`);
              }
            })
          );
        }
      }

      /******************************************
       * Our "fakeEncrypt" to match your app
       ******************************************/
      function fakeEncrypt(str) {
        return str.split("").reverse().join("");
      }

      /******************************************
       * NostrClient - like in your app
       ******************************************/
      class NostrClient {
        constructor(relayUrls) {
          this.relayUrls = relayUrls;
          this.pool = new SimplePool();
          this.pubkey = null; // will store the extension's pubkey
        }

        // Connect is trivial here; we do it on publish instead
        async init() {
          // no-op for now
        }

        // Attempt to get pubkey from extension
        async login() {
          if (!window.nostr) {
            throw new Error(
              "No window.nostr found. Please install a Nostr extension."
            );
          }
          const pubkey = await window.nostr.getPublicKey();
          this.pubkey = pubkey;
          return pubkey;
        }

        /**
         * Publish a kind=4 DM using "fake encryption".
         * This is not secure. Replace with actual encryption if needed.
         */
        async sendAppealDM(targetNpub, formDataObj) {
          if (!this.pubkey) {
            throw new Error("You must login first (no pubkey).");
          }
          // Convert target npub => hex
          let targetHex;
          try {
            targetHex = decodeNpubToHex(targetNpub);
          } catch (err) {
            throw new Error("Invalid target npub: " + err.message);
          }

          // Fake-encrypt the entire JSON
          const jsonStr = JSON.stringify(formDataObj, null, 2);
          const ciphertext = fakeEncrypt(jsonStr);

          // Build the event
          const now = Math.floor(Date.now() / 1000);
          const event = {
            kind: 4,
            pubkey: this.pubkey,
            created_at: now,
            tags: [["p", targetHex]],
            content: ciphertext,
          };

          // We need to hash the event, then sign with extension
          event.id = await getEventHash(event);
          event.sig = await window.nostr.signEvent(event);

          // Publish to all configured relays
          await this.pool.publish(Object.keys(this.relayUrls), event);
          return event;
        }
      }

      /******************************************
       * Main code
       ******************************************/
      // Configure your target npubs and relays:
      const targetNpubs = [
        // e.g. Moderation accounts:
        "npub13yarr7j6vjqjjkahd63dmr27curypehx45ucue286ac7sft27y0srnpmpe",
      ];
      const relayUrls = {
        "wss://relay.snort.social": true,
        "wss://relay.damus.io": true,
        "wss://relay.primal.net": true,
      };

      const form = document.getElementById("appeal-form");
      const statusEl = document.getElementById("status-message");

      // Create a local client
      const nostrClient = new NostrClient(relayUrls);
      // We won't call .init() for now, since we connect on publish if needed.

      form.addEventListener("submit", async (evt) => {
        evt.preventDefault();
        statusEl.textContent = "";

        // Gather form fields
        const data = new FormData(form);
        const appealData = {};
        for (const [key, val] of data.entries()) {
          appealData[key] = val.trim();
        }

        // If user is not logged in, attempt login
        if (!nostrClient.pubkey) {
          try {
            await nostrClient.login();
          } catch (err) {
            statusEl.textContent =
              "Failed to login via extension: " + err.message;
            return;
          }
        }

        let anySuccess = false;
        // For each target mod npub, send the DM
        for (const modNpub of targetNpubs) {
          try {
            await nostrClient.sendAppealDM(modNpub, appealData);
            statusEl.textContent += `Sent DM to ${modNpub}\n`;
            anySuccess = true;
          } catch (err) {
            const msg = `Failed to send DM to ${modNpub}: ${err.message}`;
            console.error(msg);
            statusEl.textContent += msg + "\n";
          }
        }

        if (anySuccess) {
          alert("Appeal submitted successfully to at least one mod npub.");
          form.reset();
        } else {
          alert("Could not submit to any target moderators. Check logs above.");
        }
      });
    </script>
  </body>
</html>
